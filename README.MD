# Multithreaded Pipeline Benchmark

[![CI](https://github.com/DavidABSiepmann/multithread_cpp/actions/workflows/ci.yml/badge.svg?branch=main)](https://github.com/DavidABSiepmann/multithread_cpp/actions/workflows/ci.yml)
[![Sanitizers](https://github.com/DavidABSiepmann/multithread_cpp/actions/workflows/sanitizers.yml/badge.svg?branch=main)](https://github.com/DavidABSiepmann/multithread_cpp/actions/workflows/sanitizers.yml)
[![Nightly Stress](https://github.com/DavidABSiepmann/multithread_cpp/actions/workflows/nightly-stress.yml/badge.svg)](https://github.com/DavidABSiepmann/multithread_cpp/actions/workflows/nightly-stress.yml)
[![Release](https://img.shields.io/github/v/release/DavidABSiepmann/multithread_cpp)](https://github.com/DavidABSiepmann/multithread_cpp/releases)

Um projeto C++ profissional que demonstra um **pipeline de processamento multithreaded** com coleta de dados, processamento paralelo e benchmarking reproduc√≠vel com an√°lise de perfil em tempo real.

---

## üìã Descri√ß√£o Curta

Este projeto implementa um **pipeline de dados em 4 est√°gios** onde m√∫ltiplas threads trabalham cooperativamente:
1. **Source A**: coleta de dados simulada
2. **Source B**: processamento e transforma√ß√£o dos dados
3. **Process A**: consumidor de Source A
4. **Process B**: consumidor de Source B com m√©trica de throughput

O projeto inclui **profiling de eventos**, **benchmarking automatizado** e **testes unit√°rios completos** com suporte a sanitizers (TSAN/ASAN).

---

## üí° Motiva√ß√£o

Este reposit√≥rio foi desenvolvido para demonstrar:

- **Padr√µes de concorr√™ncia robustos**: uso de `std::atomic`, `std::lock_guard` (RAII) e sincroniza√ß√£o thread-safe
- **Profiling de eventos em produ√ß√£o**: sistema de logging com nanosecond-precision para an√°lise de timeline
- **Benchmarking reproduc√≠vel**: framework customizado para medir throughput com varia√ß√µes param√©tricas
- **Boas pr√°ticas de C++17**: encapsulamento, polimorfismo, RAII, memory ordering
- **Qualidade de c√≥digo**: testes unit√°rios (GoogleTest), CI-ready, sem warnings
- **Documenta√ß√£o e portf√≥lio**: c√≥digo limpo, bem comentado, pronto para code review

---

## üîß Instala√ß√£o

### Pr√©-requisitos

- **C++17** ou superior
- **CMake 3.15+**
- **Python 3.7+** (para gera√ß√£o de gr√°ficos)
- **Git**

### Build via CMake

```bash
# Clone o reposit√≥rio
git clone https://github.com/DavidABSiepmann/multithread_cpp.git
cd multithread_cpp

# Build r√°pido (Release)
./scripts/build.sh

# Ou manualmente
mkdir -p build && cd build
cmake .. -DCMAKE_BUILD_TYPE=Release
cmake --build . -j$(nproc)
```

### Op√ß√µes de CMake

```bash
# Com sanitizers (para testes)
cmake .. -DENABLE_SANITIZERS=ON -DCMAKE_BUILD_TYPE=Debug

# Com documenta√ß√£o Doxygen
cmake .. -DBUILD_DOCS=ON
```

---

## üöÄ Como Usar

### Exemplo 1: Benchmark R√°pido

```bash
# Executar um bench de 3 segundos com trabalho de 10¬µs
./build/pipelines_cpp \
  --duration 3 \
  --work-us 10 \
  --repeats 3 \
  --out outputs/results.csv \
  --profile outputs/profile_events.csv
```

### Exemplo 2: Grade Completa de Benchmarks

```bash
# Roda automaticamente m√∫ltiplas combina√ß√µes
./scripts/run_bench.sh
```

Isso gera:
- `outputs/results.csv` ‚Äî tabela de throughput (threads, duration, work_us, throughput_items_s)
- `outputs/profile_events.csv` ‚Äî timeline de eventos (thread_id, timestamp_ns, event_name)

### Exemplo 3: Gerar Gr√°ficos

```bash
# Ambos os gr√°ficos (profile + results)
python3 bench/grafico.py

# Ou separadamente
python3 bench/grafico.py --profile-only
python3 bench/grafico.py --results-only
```

Gera imagens em `assets/profile.png` e `assets/results.png`.

### Par√¢metros da Linha de Comando

```
--duration S          Dura√ß√£o de cada execu√ß√£o (segundos, default: 1)
--work-us US          Trabalho simulado por item (microsegundos, default: 50)
--warmup N            N√∫mero de runs de warmup (default: 0)
--repeats R           Quantas repeti√ß√µes por c√©lula (default: 1)
--threads N           Valor registrado para n√∫mero de threads (default: 4)
--out FILE            CSV de resultados (append mode)
--profile FILE        CSV de eventos de profiling (nanosecond precision)
--help                Mostra esta mensagem
```

---

## üìä Resultados / Benchmarks

### Sa√≠da de Resultados

O CSV de resultados segue este formato:

```csv
threads,duration_s,work_us,run,processed,throughput_items_s
4,1,50,1,8234,8234.5
4,1,50,2,8401,8401.2
4,1,100,1,4567,4567.8
```

**Interpreta√ß√£o:**
- **throughput_items_s**: itens processados por segundo (m√©trica principal)
- Compare entre diferentes `work_us` para avaliar escalabilidade
- Compare entre diferentes `duration_s` para avaliar estabilidade

### Profiling Timeline

O gr√°fico de profile mostra:
- Eixo X: tempo (segundos)
- Eixo Y: threads (source_A, source_B, process_A, process_B)
- Cores: status de cada thread (running, waiting, etc.)

√ötil para detectar:
- **Gargalos**: threads que ficam idle enquanto outras trabalham
- **Balanceamento**: distribui√ß√£o desigual de carga
- **Contention**: competi√ß√£o por locks vis√≠vel como padr√µes intermitentes

---

## üõ†Ô∏è Tecnologias

| Componente | Tecnologia | Vers√£o |
|-----------|-----------|--------|
| **Linguagem** | C++ | 17 |
| **Build System** | CMake | 3.15+ |
| **Threading** | std::thread, std::atomic, std::mutex | STL |
| **Profiling** | std::chrono (nanosecond precision) | STL |
| **Testes** | GoogleTest (GTest) | FetchContent |
| **Sanitizers** | TSAN, ASAN | GCC/Clang |
| **Gr√°ficos** | Matplotlib (Python) | 3.0+ |
| **Documenta√ß√£o** | Doxygen | Markdown |
| **Versionamento** | Git | - |

**Caracter√≠sticas de Code Quality:**
- ‚úÖ Zero warnings (C++17 strict mode)
- ‚úÖ RAII (Resource Acquisition Is Initialization)
- ‚úÖ Memory-safe (atomic operations com memory ordering)
- ‚úÖ No global externs (config por dependency injection)
- ‚úÖ Header-only headers (r√°pida recompila√ß√£o)

---

## ‚úÖ Como Rodar Testes

### Testes Unit√°rios (GoogleTest)

```bash
# Build + run r√°pido
./scripts/run_tests.sh
```

Ou manualmente:

```bash
cd build
cmake .. -DCMAKE_BUILD_TYPE=Debug
cmake --build . -j
./tests/unit_tests --gtest_color=yes
```

### Testes com Sanitizers

```bash
# Com TSAN (Thread Sanitizer) para detectar race conditions
mkdir -p build && cd build
cmake .. -DENABLE_SANITIZERS=ON -DCMAKE_BUILD_TYPE=Debug
cmake --build . -j
./tests/unit_tests
```

### Cobertura de Testes

Testes incluem:

| Teste | Prop√≥sito |
|-------|----------|
| `CLI.WritesFiles` | Validar argumentos CLI e escrita de arquivos |
| `Pipeline.StartStopNoCrash` | Verificar ciclo de vida (start/stop) |
| `ProcessBuffer.IncrementsProcessed` | Validar contador de items processados |
| `BenchMetrics.IncrementAndReset` | Testar thread-safety de m√©tricas |
| `ThreadBase.StartStop` | Validar sincroniza√ß√£o de threads |
| `Throughput.Smoke` | Teste de integra√ß√£o (smoke test) |

---

## üìö Documenta√ß√£o Adicional

Para detalhes t√©cnicos, veja:

- **[ARCHITECTURE.md](./docs/ARCHITECTURE.md)** ‚Äî Design do pipeline, componentes e fluxo de dados
- **[Code Style](./docs/ARCHITECTURE.md#code-style)** ‚Äî Conven√ß√µes usadas no projeto


